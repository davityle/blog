  <!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title> QuickSort-Randomizing does not remove worst case &middot; Tyler Davis </title>
    
    <link rel="stylesheet" type="text/css" href="http://davityle.github.io/blog/css/uno.min.css" />
    <link rel="stylesheet" type="text/css" href="http://davityle.github.io/blog/css/lightGallery.css" />
    
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link href="" rel="alternate" type="application/rss+xml" title="Tyler Davis" />
    
    <script src="http://davityle.github.io/blog/js/jquery.min.js"></script>
    <script src="http://davityle.github.io/blog/js/main.min.js">
    </script>
    <script>      
      if (document.location.hostname != "localhost"){
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-59928738-1', 'auto');
        ga('send', 'pageview');
      }
    </script>
</head>

  <body>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-bars btn-mobile-menu__icon"></i>
        <i class="fa fa-times btn-mobile-close__icon hidden"></i>
    </span>
<header class="panel-cover panel-cover--collapsed"  style="background-image: url(/images/entryx1600.jpg)" >
    <div class="panel-main">
        <div class="panel-main__inner panel-inverted">
            <div class="panel-main__content"> 
                <h1 class="panel-cover__title panel-title">
                    <a href="http://davityle.github.io/blog" title="link to homepage for Tyler Davis">Tyler Davis</a>
                </h1>
                <hr class="panel-cover__divider" />
                <p class="panel-cover__description">  a blog for anyone who cares  </p>
                <hr class="panel-cover__divider panel-cover__divider--secondary" />
                <div class="navigation-wrapper">
                    <nav class="cover-navigation cover-navigation--primary">
                        <ul class="navigation">
                            <li class="navigation__item"><a href="/#blog" title="link to Tyler Davis blog" class="blog-button">Blog</a> </li>
                            </br>  </ul>
                    </nav> <nav class="cover-navigation navigation--social">
    <ul class="navigation">   
        
        <li class="navigation__item">
            <a href="https://github.com/davityle" title="davityle on github"> <i class='fa fa-github'></i> <span class="label">Github</span> </a>
        </li>  </br>   
        
        <li class="navigation__item">
            <a href="mailto:tyler@goodintheglobe.com" title="Email tyler@goodintheglobe.com"> <i class='fa fa-envelope-o'></i> <span class="label">Email</span> </a>
        </li>  </ul>
</nav>
 </div>
            </div>
        </div>
        <div class="panel-cover--overlay"></div>
    </div>
</header>

    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <div class="post">
          <h1>QuickSort-Randomizing does not remove worst case</h1>
          <span class="post-date">Sat, Jan 31, 2015</span>
          

<h2 id="toc_0">Problem</h2>

<p>I&rsquo;ve read in a few places that Randomizing the pivot point removes the worst case of O(n<span style="position: relative; bottom: 1ex; font-size: 80%;">2</span>) from the quicksort algorithm. <a href="http://en.wikipedia.org/wiki/Quicksort#Analysis_of_randomized_quicksort">Wikipedia</a> is one of those places. Other places write the whole story but don&rsquo;t show any proof. The whole story is that randomizing the pivot point does not, necessarily, remove the worst case. It&rsquo;s easy to show that this is the case. This article assumes basic knowledge of the quicksort algorithm and big O notation.</p>

<p>The worst case in quick sort happens when each pivot point always contains the next lowest, or always contains the next highest, number in the sequence.</p>

<p>For example. <br> You have an unsorted array</p>

<pre><code>array = {44,88,7,2,1,999,1040,23,123,89,2009}
</code></pre>

<p>and you want to traverse this array using random pivots. Lets just say that the random number generator produces theses numbers.</p>

<pre><code>4,3,2,7,4,7,9,8,8,9
</code></pre>

<p>Those look random enough. In fact, I would be perfectly comfortable sorting my array with those random numbers just off of the first glance.</p>

<p>Look at what actually happens when you sort the array using those pivots.</p>

<pre><code>pivot: 4, array[4] == 1
</code></pre>

<p>the pivot index is 4, the value at index 4 is 1. Notice that 1 is the lowest number in the array. After the first iteration you end up with this array</p>

<pre><code>{1,88,7,2,44,999,1040,23,123,89,2009}
</code></pre>

<p>I&rsquo;m just going to run through the rest of the iterations here. Try not to get lost.</p>

<pre><code>pivot: 3	 value: 2
array = {1,88,7,2,44,999,1040,23,123,89,2009}

pivot: 2	 value: 7
array = {1,2,7,88,44,999,1040,23,123,89,2009}

pivot: 7	 value: 23
array = {1,2,7,88,44,999,1040,23,123,89,2009}

pivot: 4	 value: 44
array = {1,2,7,23,44,999,1040,88,123,89,2009}

pivot: 7	 value: 88
{1,2,7,23,44,999,1040,88,123,89,2009}

pivot: 9	 value: 89
{1,2,7,23,44,88,1040,999,123,89,2009}

pivot: 8	 value: 123
{1,2,7,23,44,88,89,999,123,1040,2009}

pivot: 8	 value: 999
{1,2,7,23,44,88,89,123,999,1040,2009}

pivot: 9	 value: 1040
{1,2,7,23,44,88,89,123,999,1040,2009}
</code></pre>

<p>Hurray! The list is sorted. What do you notice about the number of iterations it took though? What do you notice about the values of the numbers?</p>

<p>Notice that it took about n iterations , and each iteration handled every number that wasn&rsquo;t already sorted. This results in a n operations over n iterations, or O(n<span style="position: relative; bottom: 1ex; font-size: 80%;">2</span>), operation.</p>

<p>Even though this array is sorted using a random pivot it still hit the worst possible case.</p>

<h2 id="toc_1">Proof</h2>

<p>What if you had a way to generate this worst case scenario? Luckily, I was able to reverse engineer the quicksort algorithm and produce a shuffle that always shuffles the array into the worst case scenario for quicksort (if they have the same random seed). The simple algorithm is defined below.</p>

<pre><code>/**
 * This class creates the worst case scenario for a quick sort
 */
public class QuickShuffle {
	/**
	* assumes a sorted array is passed in
	*/
	public static void quickShuffle(int[] a, Random rand){		
		int length = a.length - 1;
		int[] indexes= new int[length];
		for(int index = 0; index &lt; length; index++){
			int w = index + rand.nextInt(length - index);
			indexes[index] = w;
		}
		for(int index = indexes.length - 1; index &gt;= 0; index--){
			swap(a, index, indexes[index]);
		}
	}

	private static void swap(int[] a, int index1, int index2) {
		int temp = a[index1];
		a[index1] = a[index2];
		a[index2] = temp;
	}
}
</code></pre>

<p>Then with a quicksort that looks like this</p>

<pre><code>public class QuickSort {

	private Random rand;

	private QuickSort(Random rand){
		this.rand = rand;
	}

	public static void quickSort(int[] a, Random rand){
		new QuickSort(rand).quickSort(a, 0, a.length - 1);
	}

	private QuickSort quickSort(int[] a, int bottomIndex, int topIndex){
		if(bottomIndex&lt;topIndex){
			int pivot =switchPivot(a,bottomIndex,topIndex);
			quickSort(a,bottomIndex,pivot);
			quickSort(a,pivot+1,topIndex);
		}
		return this;
	}

	private int switchPivot(int[] a, int bottomIndex, int topIndex) {
		int index = bottomIndex + rand.nextInt(topIndex - bottomIndex);
		int value = a[index];
		int bottomSearch = bottomIndex-1 ;
		int topSearch = topIndex+1 ;

		while (true) {
		    do{
		    	bottomSearch++;
		    }while ( bottomSearch &lt; topIndex &amp;&amp; a[bottomSearch] &lt; value);

		    do{
		    	topSearch--;
		    }while (topSearch &gt; bottomIndex &amp;&amp; a[topSearch] &gt; value);

		    if (bottomSearch &lt; topSearch)
		    	swap(a, bottomSearch, topSearch);
		    else
		    	return topSearch;
		}
	}

	private void swap(int[] a, int index1, int index2) {
		int temp = a[index1];
		a[index1] = a[index2];
		a[index2] = temp;
	}
}
</code></pre>

<p>We can do some profiling and check to see if their is any validity to this worst case scenario.
I threw together this simple profiler to check out the results of a worst case scenario. (I had to increase Java&rsquo;s stack size using -Xss to run this)</p>

<pre><code>public class Main {

	private static final int NUMBER_OF_ITERATIONS= 12;
	private static final int STARTING_N = 256;

	public static void main(String[] args) {
		int n = STARTING_N;
		for(int index = 0; index &lt; NUMBER_OF_ITERATIONS; index++){
			int[] array = new int[n];
			for(int i = 0; i &lt; array.length;){
				array[i] = ++i;
			}
			QuickShuffle.quickShuffle(array, new Random(3));
			long start = System.currentTimeMillis();
			QuickSort.quickSort(array, new Random(3));
			long sameSeedResults = System.currentTimeMillis() - start;
			if(!isSorted(array))
				throw new RuntimeException();
			QuickShuffle.quickShuffle(array, new Random(3));
			start = System.currentTimeMillis();
			QuickSort.quickSort(array, new Random(4));
			long differentSeedResults = System.currentTimeMillis() - start;
			System.out.println(&quot;Same seed      : size = &quot; + n + &quot;\ttime = &quot; + sameSeedResults);
			System.out.println(&quot;Different seeds: size = &quot; + n + &quot;\ttime = &quot; + differentSeedResults);
			n &lt;&lt;= 1;
		}			
	}

	public static boolean isSorted(int[] array){
		for(int index = 0; index &lt; array.length - 1; index++){
			if(array[index] &gt; array[index + 1])
				return false;
		}
		return true;
	}
}
</code></pre>

<p>The profiler starts at n = 256 and then increases n by a power of 2 for each following iteration. Each iteration, an array of size n is created and filled with numbers from 1 - n. The array is shuffled and sorted using the same seed then the array is shuffled and sorted using different seeds. Here is the output from that profiler.</p>

<pre><code>Same seed      : size = 256	time = 1
Different seeds: size = 256	time = 1
Same seed      : size = 512	time = 0
Different seeds: size = 512	time = 1
Same seed      : size = 1024	time = 1
Different seeds: size = 1024	time = 1
Same seed      : size = 2048	time = 6
Different seeds: size = 2048	time = 1
Same seed      : size = 4096	time = 3
Different seeds: size = 4096	time = 0
Same seed      : size = 8192	time = 12
Different seeds: size = 8192	time = 1
Same seed      : size = 16384	time = 47
Different seeds: size = 16384	time = 2
Same seed      : size = 32768	time = 187
Different seeds: size = 32768	time = 3
Same seed      : size = 65536	time = 743
Different seeds: size = 65536	time = 8
Same seed      : size = 131072	time = 2960
Different seeds: size = 131072	time = 19
Same seed      : size = 262144	time = 11936
Different seeds: size = 262144	time = 34
Same seed      : size = 524288	time = 48304
Different seeds: size = 524288	time = 72
</code></pre>

<p>Holy cow. Lets look at that in a graph. (They are sorting the exact same array!)
<img src="/images/20150202030320.png" alt="Graph showing exponential curve" />
</p>

<p>The sorter using the same seed as the shuffler definitely looks exponential while the sorter using a different seed is hardly seen at all.</p>

<h2 id="toc_2">Conclusion</h2>

<p>There is a possiblity to hit the worst case using a randomized pivot point for your quicksort algorithm, but I &lsquo;forgot&rsquo; to mention that the possiblity of you finding one of these arrays that match up do perfectly in the &lsquo;wild&rsquo; is extremely rare. Using a random pivot is still probably the safest way to do it. Just don&rsquo;t forget that it is not a guarantee that you will always perform at O(n*log(n)).</p>

        </div>
        <section class="post-comments">
	<a class="muut" href="https://muut.com/i/tylerdavisinfo/comments:QuickSort-Randomizing%20does%20not%20remove%20worst%20case">Comments</a>
	<script src="//cdn.muut.com/1/moot.min.js"></script>
</section>

      </div>
    </div>
  </body>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</html>
